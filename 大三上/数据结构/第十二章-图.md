#### 基本概念
- 弧与边：两个顶点通过一条线相连，如果在无向图中，这条线称为边，在有向图中，这条线称为弧。
- 无向完全图：在一个无向图中，如果任意两个顶点都有一条直接边相连，则称改图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，有n(n-1)/2条边。
- 有向完全图：在一个有向图中，如果任意两个顶点之间都有方向互为相反的两条弧相接，则称该图为有向完全图。可以证明，在一个含有n个顶点的有向完全图中，有n(n-1)条边。

#### 图的数据结构表示
- 邻接矩阵
    + 除了用一个二维数组存储用于表示顶点之间相邻关系的邻接矩阵外，还需要一个一维数组来存储顶点信息，还有图的顶点数和边数。
- 邻接表

#### 图的遍历
- 深度优先遍历
    + 当用二维数组表示表示邻接矩阵图的存储结构的时候，查找的每个顶点的邻接点所需要的时间是O(n^2)
    + 当用邻接表作为图的存储结构的时候，查找邻接点所需要的时间是O(e),其中e为无向图中边的数或者有向图中弧的数。由此，当以邻接表作为存储结构的时候，深度优先遍历的时间复杂度为O(n + e)
- 广度优先遍历
    + 广度优先遍历遍历图的时间复杂度和深度优先遍历遍历图相同，两者的不同之处仅仅在于对顶点的访问顺序不同

#### 生成树
- 定义：所有 顶点均由边连接在一起，但不存在回路的图叫做生成树
- 最小生成树：无向联通图的生成树不是唯一的。连通图的一次遍历所经过的边的集合及图中所有顶点的集合就构成了该图的一棵生成树。如果无向连通图是一个网，那么，它的所有生成树中必有一棵边的全职总和最小的生成树，我们把它叫做最小生成树。
- Prim算法
    + 首先随机选定一个点，加入集合U，然后从生下的节点中与U中的节点相连并且边最小的边，将该点加入U，并将该边加入集合T，如此重复，直到所有的点都在集合U中，就产生了最小生成树。
    + 算法的时间复杂度为O(n^2)
- Kruskal算法
    + 首先将无向图的所有边的值按从小到大的顺序排序，从最小的边开始，将这条边的两个顶点加入集合U中，将这条边加入集合T。然后选择后面的边，如果将这条边加入集合U不会使U中的顶点形成回路，将该边加入集合T，并将不在U中的顶点加入U。一直重复上面的步骤，知道所有顶点都在U中。
    + 算法的时间复杂度为O(loge)

